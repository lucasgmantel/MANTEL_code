"""This script calculates both the Solvent-Accessible Surface Area
(SASA) and the Relative Solvent Accessibility (RSA) of each residue
of a given protein using an algorithm based on Shrake and Rupley's
method. It also compares the results with those obtained using the
FreeSASA Python library. The script displays the SASA values and
generates a bar plot comparing the RSA values from both methods.
The bar plot is saved as a PNG file in the './results' directory.
---------------------------------------------------------------------
Usage:

In a terminal, move to the `MANTEL_code/src` directory and run the 
following command:

    python sasa.py <pdb_file>

Example:

    python sasa.py ../data/1AKI.pdb
---------------------------------------------------------------------
"""

import math
import os
from pathlib import Path
import sys

import Bio.PDB
import freesasa
import matplotlib.pyplot as plt

VDW_RADII = {
    "H": 1.20, "C": 1.70, "N": 1.55, "O": 1.52, "S": 1.80,
}

MAX_ASA = {
    "ALA": 121, "ARG": 265, "ASN": 187, "ASP": 187, "CYS": 148,
    "GLN": 214, "GLU": 214, "GLY": 97, "HIS": 216, "ILE": 195,
    "LEU": 191, "LYS": 230, "MET": 203, "PHE": 228, "PRO": 154,
    "SER": 143, "THR": 163, "TRP": 264, "TYR": 255, "VAL": 165
}


def check_arguments():
    """Check if the script is run with exactly one argument.

    Raises:
    -------
        SystemExit: If the number of arguments is not equal to 2.
    """
    if len(sys.argv) != 2:
        sys.exit("ERROR : expecting exactly 1 argument.")


def verify_file_type(file_name):
    """Verify that the provided file is a PDB file.

    Args:
    -----
        file_name (str): The name of the file to check.
    Raises:
    -------
        SystemExit: If the file does not have a .pdb extension.
    """
    if not file_name.endswith(".pdb"):
        sys.exit("ERROR : file must be a .pdb file.")


def load_structure(file_name):
    """Load a PDB structure from a file.

    Args:
    -----
        file_name (str): The name of the PDB file.
    Returns:
    --------
        structure (Bio.PDB.Structure): The loaded PDB structure.
    Raises:
    -------
        SystemExit: If the file does not exist.
    """
    if Path(file_name).exists():
        parser = Bio.PDB.PDBParser(QUIET=True)
        structure = parser.get_structure("structure", file_name)
        return structure
    else:
        sys.exit(f"ERROR : file {file_name} does not exist.")


def get_atom_coordinates(structure):
    """Extract coordinates of all non-water atoms from the structure.

    Args:
    -----
        structure (Bio.PDB.Structure): The PDB structure.
    Returns:
    --------
        list: A list of tuples containing atoms and their coordinates.
    """
    # Water molecules (resname "HOH") are excluded.
    all_atoms = [atom for atom in structure.get_atoms()
                 if atom.get_parent().get_resname() != "HOH"]
    coords = [atom.coord for atom in all_atoms]
    return [(all_atoms[i], coords[i]) for i in range(len(all_atoms))]


def load_sphere_points(file_path="sphere.txt"):
    """Load sphere points from a file generated by the sph_saff.py script.
    The sphere consists of 92 points uniformly distributed on a unit sphere
    centered on (0, 0, 0). The sphe_saff.py script generates the coordinates
    of these points by applying the Saff and Kuijlaars algorithm.

    Args:
    -----
        file_path (str): The path to the sphere points file. Default is
        "sphere.txt".
    Returns:
    --------
        list: A list of tuples containing the (x, y, z) coordinates of the
        sphere points.
    """
    with open(file_path, "r") as f:
        # The first 2 lines must be skipped (metadata).
        lines = f.readlines()[2:]
    points = []
    for line in lines:
        x, y, z = map(float, line.strip().split())
        points.append((x, y, z))
    return points


def generate_atom_sphere(atom_coord, vdw_radius, sphere_points):
    """Generate a sphere of points centered on the atom's coordinates. The
    sphere points are scaled according to the atom's Van der Waals radius
    plus the probe radius of the solvent (water, 1.4 Å).

    Args:
    -----
        atom_coord (tuple): The (x, y, z) coordinates of the atom.
        vdw_radius (float): The Van der Waals radius of the atom.
        sphere_points (list): A list of tuples containing the (x, y, z)
        coordinates of the sphere points.
    Returns:
    --------
        list: A list of tuples containing the (x, y, z) coordinates of the
        scaled sphere points centered on the atom.
    """
    total_radius = vdw_radius + 1.4
    scaled_points = []
    for (x, y, z) in sphere_points:
        # Scale and translate the points to center the sphere on the atom.
        new_x = atom_coord[0] + x * total_radius
        new_y = atom_coord[1] + y * total_radius
        new_z = atom_coord[2] + z * total_radius
        scaled_points.append((new_x, new_y, new_z))
    return scaled_points


def is_point_exposed(point, all_atoms, current_atom, vdw_radii):
    """Check if a point on the sphere of the current atom is exposed to the
    solvent or if it collides with the sphere of another atom.

    Args:
    -----
        point (tuple): The (x, y, z) coordinates of the point to check.
        all_atoms (list): A list of tuples containing atoms and their
        coordinates.
        current_atom (Bio.PDB.Atom): The atom for which the point is being
        checked.
        vdw_radii (dict): A dictionary mapping element symbols to their
        Van der Waals radii.
    Returns:
    --------
        bool: True if the point is exposed to the solvent, False if it
        collides with another atom.
    """
    for atom, coord in all_atoms:
        if atom == current_atom:
            continue  # Ignore the current atom.
        element = atom.element.upper()
        if element not in vdw_radii:
            continue  # Ignore atoms without defined radius.
        # Distance between the point and the atom.
        distance = math.sqrt(
            (point[0] - coord[0])**2 +
            (point[1] - coord[1])**2 +
            (point[2] - coord[2])**2
        )
        # Check for collision.
        if distance < vdw_radii[element] + 1.4:
            return False  # Point collides with another atom.
    return True  # Point is exposed.


def calculate_sasa(all_atoms, sphere_points, vdw_radii):
    """Calculate the Solvent-Accessible Surface Area (SASA) for each residue
    in the structure using the Shrake and Rupley method.

    Args:
    -----
        all_atoms (list): A list of tuples containing atoms and their
        coordinates.
        sphere_points (list): A list of tuples containing the (x, y, z)
        coordinates of the sphere points.
        vdw_radii (dict): A dictionary mapping element symbols to their
        Van der Waals radii.
    Returns:
    --------
        dict: A dictionary mapping residue identifiers to their SASA values.
    """
    # Dictionnary to store spheres for each atom.
    atom_spheres = {}
    # Generation of spheres for all atoms.
    for atom, coord in all_atoms:
        element = atom.element.upper()
        if element not in vdw_radii:
            continue  # Ignore atoms without defined radius.
        # Generate the sphere for the current atom.
        sphere = generate_atom_sphere(coord, vdw_radii[element], sphere_points)
        atom_spheres[atom] = sphere  # Store current atom's sphere.
    # Calculate exposed points for each atom
    sasa_per_residue = {}
    for atom, coord in all_atoms:
        element = atom.element.upper()
        if element not in vdw_radii:
            continue  # Ignore atoms without defined radius.
        # Retrieve the sphere for this atom.
        sphere = atom_spheres[atom]
        exposed_points = 0
        # For each point in the sphere of this atom.
        for point in sphere:
            # Check for collisions with the spheres of other atoms.
            if is_point_exposed(point, all_atoms, atom, vdw_radii):
                exposed_points += 1
        # Compute SASA for this atom.
        R = vdw_radii[element] + 1.4
        point_area = (4 * math.pi * (R**2)) / len(sphere_points)
        atom_sasa = point_area * exposed_points
        # Accumulate SASA per residue.
        # Get residue identifier (resname + resnum).
        residue_id = atom.get_parent().get_id()[1]
        residue_name = atom.get_parent().get_resname()
        residue_key = f"{residue_name}{residue_id}"
        # Initialize if not already present.
        if residue_key not in sasa_per_residue:
            sasa_per_residue[residue_key] = 0
        # Add atom's SASA to the residue's total SASA.
        sasa_per_residue[residue_key] += atom_sasa
    return sasa_per_residue


def display_results(structure, pdb_file):
    """Display the total SASA computed by both the implemented algorithm and
    FreeSASA and generates a bar plot comparing RSA values (Relative Solvent
    Accessibility) per residue from the implemented algorithm and FreeSASA.

    Args:
    -----
        structure (Bio.PDB.Structure): The PDB structure.
        pdb_file (str): The name of the PDB file.
    """
    # Computation of total SASA using the implemented algorithm.
    print("\n###  Computing total Solvent-Accessible Surface Area (SASA) using the implemented algorithm...  ###\n")
    all_atoms = get_atom_coordinates(structure)
    sphere_points = load_sphere_points()
    sasa_per_residue = calculate_sasa(all_atoms, sphere_points, VDW_RADII)
    total_sasa = sum(sasa_per_residue.values())
    print(f"     Total SASA : {total_sasa:.1f} Å²")
    # Computation of total SASA using FreeSASA.
    print("\n###  Computing total Solvent-Accessible Surface Area (SASA) using FreeSASA...  ###\n")
    structure_conv = freesasa.structureFromBioPDB(structure)
    result = freesasa.calc(structure_conv)
    print(f"     Total SASA : {result.totalArea():.1f} Å²")
    # Computation of RSA (Relative Solvent Accessibility) per residue.
    print("\n###  Computing Relative Solvent Accessibility (RSA)...  ###\n")
    # Extraction of SASA per residue from FreeSASA results.
    res_areas_freesasa = result.residueAreas()
    # Preparing the data for the bar plot.
    residues_labels = []
    rsa_freesasa_values = []
    rsa_manual_values = []
    # Loop through residues to compute RSA values.
    for chain, residues in res_areas_freesasa.items():
        for resnum, resinfo in residues.items():
            # Get residue name and number.
            resname = resinfo.residueType
            residue_key = f"{resname}{resnum}"
            # Get SASA values from both methods for this residue.
            sasa_freesasa = resinfo.total
            sasa_manual = sasa_per_residue.get(residue_key, 0.0)
            # Computation of RSA (Relative Solvent Accessibility) per residue.
            if resname in MAX_ASA:
                rsa_freesasa = (sasa_freesasa / MAX_ASA[resname]) * 100
                rsa_manual = (sasa_manual / MAX_ASA[resname]) * 100
                # Store values for plotting.
                residues_labels.append(residue_key)
                rsa_freesasa_values.append(rsa_freesasa)
                rsa_manual_values.append(rsa_manual)
    # Generating the bar plot.
    x = range(len(residues_labels))
    width = 0.35  # Width of the bars.
    fig, ax = plt.subplots(figsize=(15, 8))
    # Bars for RSA values from both methods.
    rects1 = ax.bar([i - width/2 for i in x],
                    rsa_freesasa_values,
                    width,
                    label='FreeSASA',
                    color='blue')
    rects2 = ax.bar([i + width/2 for i in x],
                    rsa_manual_values,
                    width,
                    label='Implemented Algorithm',
                    color='red')
    # Adding labels and title.
    ax.set_ylabel('Relative Solvent Accessibility (%)')
    ax.set_xlabel('Residues')
    ax.set_xticks(x)
    ax.set_xticklabels(residues_labels, rotation=90, fontsize=7)
    plt.margins(x=0.01)
    ax.legend()
    plt.tight_layout()
    # Save figure as PNG.
    filename = os.path.basename(pdb_file)
    basename = os.path.splitext(filename)[0]
    plt.savefig(f'../results/{basename}_rsa.png',
                dpi=600,
                bbox_inches='tight')
    plt.close()
    print(f"     RSA Figure saved at ../results/{basename}_rsa.png")
    print("\n###  Computation run successfully !  ###\n")


def main():
    check_arguments()
    PDB_FILE = sys.argv[1]
    verify_file_type(PDB_FILE)
    PROTEIN = load_structure(PDB_FILE)
    display_results(PROTEIN, PDB_FILE)


if __name__ == "__main__":
    main()
